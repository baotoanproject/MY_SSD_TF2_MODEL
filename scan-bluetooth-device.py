#!/usr/bin/env python3
"""
Bluetooth Scanner ƒë∆°n gi·∫£n - Qu√©t ƒëi·ªán tho·∫°i g·∫ßn ƒë√≥
"""

import subprocess
import time
import json
import re
import signal
import sys
import sqlite3
import hashlib
import requests
from datetime import datetime, timedelta

class SimpleBluetoothScanner:
    def __init__(self, server_url="https://dev-api.wayfindy.com"):
        self.devices = {}
        self.running = True
        self.scan_count = 0
        self.db_file = "device_history.db"
        self.server_url = server_url
        self.sent_events = {}  # Track sent events: {mac_hash: {'new_sent': bool, 'return_sent': bool}}
        self.init_database()
        
    def init_database(self):
        """Kh·ªüi t·∫°o SQLite database"""
        try:
            conn = sqlite3.connect(self.db_file)
            cursor = conn.cursor()
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS devices (
                    mac_hash TEXT PRIMARY KEY,
                    device_name TEXT,
                    device_type TEXT,
                    first_seen TIMESTAMP,
                    last_seen TIMESTAMP,
                    visit_count INTEGER DEFAULT 1,
                    total_detections INTEGER DEFAULT 1
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS detections (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    mac_hash TEXT,
                    detection_time TIMESTAMP,
                    scan_number INTEGER,
                    FOREIGN KEY (mac_hash) REFERENCES devices (mac_hash)
                )
            ''')
            
            conn.commit()
            conn.close()
            print("‚úÖ Database initialized")
        except Exception as e:
            print(f"‚ùå Database error: {e}")
    
    def signal_handler(self, sig, frame):
        print("\nüõë D·ª´ng qu√©t...")
        self.running = False
        if self.devices:
            self.save_results()
        self.show_statistics()
        sys.exit(0)
    
    def check_bluetooth(self):
        """Ki·ªÉm tra Bluetooth"""
        try:
            result = subprocess.run(['hcitool', 'dev'], capture_output=True, text=True)
            if result.returncode == 0 and 'hci' in result.stdout:
                print("‚úÖ Bluetooth s·∫µn s√†ng")
                return True
            else:
                print("‚ùå Kh√¥ng t√¨m th·∫•y Bluetooth adapter")
                return False
        except:
            print("‚ùå L·ªói ki·ªÉm tra Bluetooth")
            return False
    
    def scan_nearby_devices(self):
        """Qu√©t thi·∫øt b·ªã b·∫±ng hcitool"""
        print("üîç ƒêang qu√©t thi·∫øt b·ªã Bluetooth...")
        
        try:
            # Qu√©t thi·∫øt b·ªã
            result = subprocess.run(['hcitool', 'scan'], 
                                  capture_output=True, text=True, timeout=15)
            
            if result.returncode == 0:
                return self.parse_hcitool_output(result.stdout)
            else:
                print("‚ùå L·ªói khi qu√©t")
                return []
        except subprocess.TimeoutExpired:
            print("‚è∞ Timeout khi qu√©t")
            return []
        except Exception as e:
            print(f"‚ùå L·ªói: {e}")
            return []
    
    def parse_hcitool_output(self, output):
        """Parse k·∫øt qu·∫£ t·ª´ hcitool scan"""
        devices = []
        lines = output.strip().split('\n')
        
        for line in lines[1:]:  # B·ªè d√≤ng header
            line = line.strip()
            if line and '\t' in line:
                parts = line.split('\t', 1)
                if len(parts) == 2:
                    mac = parts[0].strip()
                    name = parts[1].strip() if parts[1].strip() else "Kh√¥ng c√≥ t√™n"
                    
                    device_type = self.classify_device(name)
                    
                    # Ch·ªâ x·ª≠ l√Ω thi·∫øt b·ªã ƒëi·ªán tho·∫°i
                    if not device_type.startswith("üì±"):
                        continue
                        
                    device = {
                        'mac': mac,
                        'name': name,
                        'type': device_type,
                        'time': datetime.now().strftime("%H:%M:%S"),
                        'scan_number': self.scan_count
                    }
                    
                    devices.append(device)
                    self.devices[mac] = device
                    
                    # L∆∞u v√†o database v√† ki·ªÉm tra kh√°ch quay l·∫°i
                    is_returning = self.save_to_database(mac, name, device['type'])
                    
                    status = "üîÑ QUAY L·∫†I" if is_returning else "üÜï M·ªöI"
                    # Hi·ªÉn th·ªã MAC hash thay v√¨ MAC th·∫≠t ƒë·ªÉ b·∫£o m·∫≠t
                    mac_display = self.hash_mac_address(mac)[:8] + "..."
                    print(f"üì± {name} ({mac_display}) - {device['type']} [{status}]")
                    
                    # G·ª≠i event ƒë·∫øn server
                    self.send_scanner_event(mac, name, device['type'], is_returning)
        
        return devices
    
    def classify_device(self, name):
        """Ph√¢n lo·∫°i thi·∫øt b·ªã"""
        name_lower = name.lower()
        
        if any(phone in name_lower for phone in ['iphone', 'galaxy', 'pixel', 'xiaomi', 'samsung', 'huawei', 'oppo', 'vivo', 'oneplus', 'phone']):
            return "üì± ƒêi·ªán tho·∫°i"
        elif any(audio in name_lower for audio in ['airpods', 'headphone', 'speaker', 'buds', 'audio', 'beats']):
            return "üéµ √Çm thanh"
        elif any(computer in name_lower for computer in ['macbook', 'laptop', 'pc', 'desktop']):
            return "üíª M√°y t√≠nh"
        elif any(watch in name_lower for watch in ['watch', 'band', 'fitbit']):
            return "‚åö ƒê·ªìng h·ªì"
        else:
            return "‚ùì Kh√°c"
    
    def hash_mac_address(self, mac):
        """Hash MAC address ƒë·ªÉ b·∫£o m·∫≠t"""
        # S·ª≠ d·ª•ng SHA-256 v·ªõi salt ƒë·ªÉ hash MAC address
        salt = "bluetooth_scanner_2024"  # C√≥ th·ªÉ ƒë·ªïi salt n√†y
        mac_with_salt = f"{mac}{salt}"
        return hashlib.sha256(mac_with_salt.encode()).hexdigest()[:16]
    
    def send_scanner_event(self, mac, name, device_type, is_returning):
        """G·ª≠i event ƒë·∫øn server - ch·ªâ g·ª≠i 1 l·∫ßn cho m·ªói tr·∫°ng th√°i"""
        mac_hash = self.hash_mac_address(mac)
        
        # Ki·ªÉm tra ƒë√£ g·ª≠i event n√†y ch∆∞a
        if mac_hash not in self.sent_events:
            self.sent_events[mac_hash] = {'new_sent': False, 'return_sent': False}
        
        # Ki·ªÉm tra c√≥ n√™n g·ª≠i event kh√¥ng
        should_send = False
        event_type = ""
        
        if not is_returning and not self.sent_events[mac_hash]['new_sent']:
            # Thi·∫øt b·ªã m·ªõi l·∫ßn ƒë·∫ßu xu·∫•t hi·ªán
            should_send = True
            event_type = "new_device"
            self.sent_events[mac_hash]['new_sent'] = True
            
        elif is_returning and not self.sent_events[mac_hash]['return_sent']:
            # Thi·∫øt b·ªã quay l·∫°i l·∫ßn ƒë·∫ßu
            should_send = True  
            event_type = "returning_device"
            self.sent_events[mac_hash]['return_sent'] = True
        
        if not should_send:
            print(f"‚è≠Ô∏è Event already sent for {name} ({mac_hash[:8]}...) - skipping")
            return
        
        try:
            payload = {
                "eventType": "device_detected",
                "deviceId": mac_hash,
                "deviceName": name,
                "deviceType": device_type,
                "isReturning": is_returning,
                "timestamp": datetime.now().isoformat(),
                "scannerId": "pi_scanner_01"
            }
            
            response = requests.post(
                f"{self.server_url}/beacon/pi-scanner-event",
                json=payload,
                timeout=5,
                headers={"Content-Type": "application/json"}
            )
            
            if response.status_code == 200:
                print(f"‚úÖ Event sent to server ({event_type})")
            else:
                error_message = f"Server responded with status {response.status_code}"
                try:
                    error_detail = response.json().get('message', 'No error message')
                    error_message += f" - {error_detail}"
                except:
                    error_message += f" - Response: {response.text[:100]}..."
                print(f"‚ö†Ô∏è {error_message}")
                
        except requests.exceptions.Timeout as e:
            print(f"‚ùå Timeout error when sending event: Connection timeout after 5 seconds")
            # Reset flag n·∫øu g·ª≠i th·∫•t b·∫°i
            if event_type == "new_device":
                self.sent_events[mac_hash]['new_sent'] = False
            elif event_type == "returning_device":
                self.sent_events[mac_hash]['return_sent'] = False
        except requests.exceptions.ConnectionError as e:
            print(f"‚ùå Connection error when sending event: Cannot connect to server {self.server_url}")
            # Reset flag n·∫øu g·ª≠i th·∫•t b·∫°i
            if event_type == "new_device":
                self.sent_events[mac_hash]['new_sent'] = False
            elif event_type == "returning_device":
                self.sent_events[mac_hash]['return_sent'] = False
        except requests.exceptions.RequestException as e:
            print(f"‚ùå HTTP request error when sending event: {str(e)}")
            # Reset flag n·∫øu g·ª≠i th·∫•t b·∫°i
            if event_type == "new_device":
                self.sent_events[mac_hash]['new_sent'] = False
            elif event_type == "returning_device":
                self.sent_events[mac_hash]['return_sent'] = False
        except Exception as e:
            print(f"‚ùå Unexpected error when sending event: {str(e)} (Type: {type(e).__name__})")
            # Reset flag n·∫øu c√≥ l·ªói
            if event_type == "new_device":
                self.sent_events[mac_hash]['new_sent'] = False
            elif event_type == "returning_device":
                self.sent_events[mac_hash]['return_sent'] = False
    
    def save_to_database(self, mac, name, device_type):
        """L∆∞u thi·∫øt b·ªã v√†o database v√† tr·∫£ v·ªÅ True n·∫øu l√† kh√°ch quay l·∫°i"""
        try:
            conn = sqlite3.connect(self.db_file)
            cursor = conn.cursor()
            current_time = datetime.now()
            
            # Hash MAC address ƒë·ªÉ b·∫£o m·∫≠t
            mac_hash = self.hash_mac_address(mac)
            
            # Ki·ªÉm tra thi·∫øt b·ªã ƒë√£ t·ªìn t·∫°i ch∆∞a
            cursor.execute("SELECT visit_count, last_seen FROM devices WHERE mac_hash = ?", (mac_hash,))
            result = cursor.fetchone()
            
            is_returning = False
            
            if result:
                # Thi·∫øt b·ªã ƒë√£ t·ªìn t·∫°i
                visit_count, last_seen_str = result
                last_seen = datetime.fromisoformat(last_seen_str)
                
                # N·∫øu l·∫ßn th·∫•y cu·ªëi c√°ch ƒë√¢y > 15 ph√∫t th√¨ t√≠nh l√† quay l·∫°i
                if current_time - last_seen > timedelta(minutes=15):
                    visit_count += 1
                    is_returning = True
                
                # C·∫≠p nh·∫≠t th√¥ng tin
                cursor.execute('''
                    UPDATE devices 
                    SET device_name = ?, last_seen = ?, visit_count = ?, total_detections = total_detections + 1
                    WHERE mac_hash = ?
                ''', (name, current_time.isoformat(), visit_count, mac_hash))
            else:
                # Thi·∫øt b·ªã m·ªõi
                cursor.execute('''
                    INSERT INTO devices (mac_hash, device_name, device_type, first_seen, last_seen, visit_count, total_detections)
                    VALUES (?, ?, ?, ?, ?, 1, 1)
                ''', (mac_hash, name, device_type, current_time.isoformat(), current_time.isoformat()))
            
            # Ghi l·∫°i l·∫ßn ph√°t hi·ªán n√†y
            cursor.execute('''
                INSERT INTO detections (mac_hash, detection_time, scan_number)
                VALUES (?, ?, ?)
            ''', (mac_hash, current_time.isoformat(), self.scan_count))
            
            conn.commit()
            conn.close()
            
            return is_returning
            
        except Exception as e:
            print(f"‚ùå Database save error: {e}")
            return False
    
    def get_visitor_stats(self):
        """L·∫•y th·ªëng k√™ kh√°ch"""
        try:
            conn = sqlite3.connect(self.db_file)
            cursor = conn.cursor()
            
            # T·ªïng s·ªë thi·∫øt b·ªã
            cursor.execute("SELECT COUNT(*) FROM devices")
            total_devices = cursor.fetchone()[0]
            
            # Kh√°ch quay l·∫°i
            cursor.execute("SELECT COUNT(*) FROM devices WHERE visit_count > 1")
            returning_visitors = cursor.fetchone()[0]
            
            # Kh√°ch h√¥m nay
            today = datetime.now().date()
            cursor.execute("SELECT COUNT(*) FROM devices WHERE date(last_seen) = ?", (today,))
            today_visitors = cursor.fetchone()[0]
            
            conn.close()
            
            return {
                'total': total_devices,
                'returning': returning_visitors,
                'today': today_visitors
            }
        except Exception as e:
            print(f"‚ùå Stats error: {e}")
            return {'total': 0, 'returning': 0, 'today': 0}
    
    def show_statistics(self):
        """Hi·ªÉn th·ªã th·ªëng k√™"""
        stats = self.get_visitor_stats()
        print("\n" + "="*50)
        print("üìä TH·ªêNG K√ä KH√ÅCH")
        print(f"   üë• T·ªïng s·ªë thi·∫øt b·ªã: {stats['total']}")
        print(f"   üîÑ Kh√°ch quay l·∫°i: {stats['returning']}")
        print(f"   üìÖ Kh√°ch h√¥m nay: {stats['today']}")
        print("="*50)
    
    def save_results(self):
        """L∆∞u k·∫øt qu·∫£ v·ªõi MAC hash"""
        filename = f"bluetooth_scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        try:
            # T·∫°o d·ªØ li·ªáu v·ªõi MAC hash thay v√¨ MAC th·∫≠t
            safe_devices = {}
            for mac, device in self.devices.items():
                mac_hash = self.hash_mac_address(mac)
                safe_devices[mac_hash] = {
                    'name': device['name'],
                    'type': device['type'],
                    'time': device['time'],
                    'scan_number': device['scan_number']
                }
            
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(safe_devices, f, ensure_ascii=False, indent=2)
            print(f"üíæ ƒê√£ l∆∞u {len(safe_devices)} thi·∫øt b·ªã v√†o {filename}")
        except Exception as e:
            print(f"‚ùå L·ªói l∆∞u file: {e}")
    
    def run_continuous_scan(self):
        """Ch·∫°y qu√©t li√™n t·ª•c"""
        print("üöÄ B·∫ÆT ƒê·∫¶U QU√âT BLUETOOTH")
        print("=" * 50)
        print("üîí MAC address ƒë∆∞·ª£c hash ƒë·ªÉ b·∫£o m·∫≠t")
        print("üí° Nh·∫•n Ctrl+C ƒë·ªÉ d·ª´ng")
        print("=" * 50)
        
        while self.running:
            self.scan_count += 1
            print(f"\nüîÑ L·∫ßn qu√©t #{self.scan_count} - {datetime.now().strftime('%H:%M:%S')}")
            
            devices_found = self.scan_nearby_devices()
            
            if devices_found:
                print(f"‚úÖ T√¨m th·∫•y {len(devices_found)} thi·∫øt b·ªã")
            else:
                print("‚ö™ Kh√¥ng t√¨m th·∫•y thi·∫øt b·ªã n√†o")
            
            # Hi·ªÉn th·ªã th·ªëng k√™ ng·∫Øn g·ªçn
            stats = self.get_visitor_stats()
            print(f"üìä T·ªïng: {stats['total']} | Quay l·∫°i: {stats['returning']} | H√¥m nay: {stats['today']}")
            
            # Ch·ªù 5 gi√¢y tr∆∞·ªõc l·∫ßn qu√©t ti·∫øp theo
            try:
                print("‚è≥ Ch·ªù 5 gi√¢y...")
                time.sleep(5)
            except KeyboardInterrupt:
                break

def main():
    import argparse
    
    parser = argparse.ArgumentParser(description='Bluetooth Scanner v·ªõi API integration')
    parser.add_argument('--server-url', default='https://dev-api.wayfindy.com',
                       help='Server URL (default: https://dev-api.wayfindy.com)')
    
    args = parser.parse_args()
    
    scanner = SimpleBluetoothScanner(server_url=args.server_url)
    
    print(f"üåê Server URL: {args.server_url}")
    
    # ƒêƒÉng k√Ω signal handler
    signal.signal(signal.SIGINT, scanner.signal_handler)
    
    # Ki·ªÉm tra Bluetooth
    if not scanner.check_bluetooth():
        print("üí° C√†i ƒë·∫∑t: sudo apt install bluetooth bluez-utils")
        sys.exit(1)
    
    # B·∫Øt ƒë·∫ßu qu√©t
    scanner.run_continuous_scan()

if __name__ == "__main__":
    main()